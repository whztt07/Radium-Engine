<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Radium Engine: Material management in the Radium Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">28bf594254a312693a0e8cbb8f95fa3e00d4a506</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_travis_build_STORM-IRIT_Radium-Engine_Docs_material.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Material management in the Radium Engine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A Material is a way to control the appearance of an object when rendering. It could be the definition of a classical rendering materials, a <em>Bidirectionnal Scattering Distribution function (BSDF)</em>, or just define the way a geometry could be rendered and how is computed the final color of an object.</p>
<p>A material is associated to the renderable geometry of an object (a component in the Radium nomenclature) through a so called <em>Render Technique</em>. This association is managed by the <code>RenderObject</code> class.</p>
<p>This documentation aims at describing the way materials are managed in the Radium engine and how one can extend the set of available material, or specialized a renderer with ad-hoc (pseudo)-material.</p>
<h2>Material subsystem and Material Library</h2>
<p>The Radium Engine defines an abstract interface for material definition that allows easy extensibility of the Engine. This section describe the workflow of Material management from asset loading to rendering. Note that, for a given application or renderer, a Material could be defined directly without loading it from a file.</p>
<h3>The MaterialData interface</h3>
<p>The interface <code>MaterialData</code> define the external representation of a material. Even if this interface could be instanciated, it defines an abstract material that is not valid for the Engine. This interface must then be implemented to define materials that could be loaded from a file.</p>
<p>When defining a loadable material, the corresponding implementation must set the type of the material to a unique identifier that will be used after that to automatically generate different instances of the material. The implementation of the interface <code>MaterialData</code> can add whatever functions needed to construct and interact with the external representation of a material. These functions might then be used by the file loader able to understand this material and by the material converter, described below, that will be used by some systems to convert this external material definition to the Engine internal representation.</p>
<h3>The Material interface</h3>
<p>The <code>Material</code> interface defines the internal abstract representation of a Material. This interface will be used by the Engine, mainly by the <em>Render Technique</em> and the renderers.</p>
<p>This interface defines all the methods needed to parametrized the OpenGL pipeline for rendering. When implementing this interface, it is a good idea to add two static methods to the implementation to allow to register and unregister the material into the Engine. These method could have the following profiles : ```cpp class MyMaterial : public <a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a> { public: // implementation of the abstract interface ... private: // data member for MyMaterial ... public: static void registerMaterial(); static void unregisterMaterial(); // MyMaterial specific public interface ... } ```</p>
<h3>Material converters</h3>
<p>This is used by the loading system to translate the external representation of a material to the internal one and associate this internal representation to a <code>RenderTechnique</code> inside a <code>RenderObject</code>component.</p>
<p>A material converter is a couple <code>&lt;std::string, std::function&lt;<a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a>*(<a class="el" href="classRa_1_1Asset_1_1MaterialData.html" title="represent material data loaded by a file loader. ">Ra::Asset::MaterialData</a>*)&gt;&gt;</code> where the string gives the type of the material and the function is whatever is compatible with std::function :</p>
<ul>
<li>a lambda</li>
<li>a functor</li>
<li>a function with bind parameters ...</li>
</ul>
<p>The function is in charge of converting a concrete <code><a class="el" href="classRa_1_1Asset_1_1MaterialData.html" title="represent material data loaded by a file loader. ">Ra::Asset::MaterialData</a> *</code> to a concrete <code><a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a> *</code> according to the type of material described by the string ...</p>
<p>Material converters are managed by the engine through a Factory defined in the <code>namespace <a class="el" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html">Ra::Engine::EngineMaterialConverters</a></code> and located in the <code>Engine/Renderer/Material</code> directory as below : ```cpp namespace EngineMaterialConverters { using AssetMaterialPtr = const <a class="el" href="classRa_1_1Asset_1_1MaterialData.html" title="represent material data loaded by a file loader. ">Ra::Asset::MaterialData</a>*; using RadiumMaterialPtr = <a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a>*; using ConverterFunction = std::function&lt; RadiumMaterialPtr( AssetMaterialPtr ) &gt;;</p>
<p>/** register a new material converter RA_ENGINE_API bool registerMaterialConverter( const std::string&amp; name, ConverterFunction converter );</p>
<p>/** remove a material converter RA_ENGINE_API bool removeMaterialConverter( const std::string&amp; name );</p>
<p>/** Get a material converter RA_ENGINE_API std::pair&lt;bool, ConverterFunction&gt; getMaterialConverter( const std::string&amp; name );</p>
<p>} // namespace EngineMaterialConverters ```</p>
<h3>Render technique and materials</h3>
<p>A <code>RenderTechnique</code> correspond to the description of how to use Materials to render an object in openGL. Even if <code>RenderTechnique</code> is tightly coupled with the default <code>ForwardRenderer</code> of the engine, it could be used also with other renderers. Note nevertheless that RenderTechnique is not mandatory when defining a specific renderer as the association between the material and the geometry of a render object could be done explicitely.</p>
<p>To manage the way a Material could be used for rendering, a <code>RenderTechnique</code> is then a set of <em>shader configurations</em> associated to the different way a renderer will compute the final image. Based on the <code>ForwardRenderer</code> implementation in Radium, the set of configurations, with one configuration per rendering <em>passes</em> corresponds to the following :</p>
<ol type="1">
<li>Depth and ambiant/environment lighting :<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51dae13b847fdf01551fa704a192597e376c">Ra::Engine::RenderTechnique::Z_PREPASS</a></code> constant.</li>
<li>Required for the depth pre-pass of several renderers.</li>
<li>Must initialise the color buffer with the computation of ambiant/environment lighting.</li>
<li>Default/Reference : DepthAmbiantPass shaders</li>
</ul>
</li>
<li>Opaque lighting **(MANDATORY for default ForwardRenderer)**:<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da9c843288b3e60ed141014569ae035c0e">Ra::Engine::RenderTechnique::LIGHTING_OPAQUE</a></code> constant.</li>
<li>Main configuration, computes the resulting color according to a lighting configuration.</li>
<li>The lighting configuration might contains one or several sources of different types.</li>
<li>Default/Reference : BlinnPhong shaders</li>
</ul>
</li>
<li>Transparent lighting :<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da8cb69950239b9f21365388db545a64fd">Ra::Engine::RenderTechnique::LIGHTING_TRANSPARENT</a></code> constant.</li>
<li>Same as opaque lighting but for transparent objects</li>
<li>Default/Reference LitOIT shaders</li>
</ul>
</li>
</ol>
<p><b>Note</b> that a specific renderer might use the same set of configurations but with a different semantic. One can imagine, for instance, that a renderer will only use the <em>Depth and ambiant/environment</em> configuration in order to render an object without light source but with a specific color computation.</p>
<p>RenderTechniques are associated with Materials through a Builder Factory defined in the <code>namespace <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html">Ra::Engine::EngineRenderTechniques</a></code> and located in the <code>Engine/Renderer/RenderTechnique</code> directory. This factory will manage default technique builders for each registered materials in the engine. A default technique builder will associate a set of predefined shaders for each rendering pass to a Material type.</p>
<p>This association is based on the type, not on the instance. So it can vary from one instance to the other but requires then a manual construction of the render technique instead of an automatic one through the factory.</p>
<p>The <code>RenderTechnique</code> factory is defined as below : ```cpp namespace EngineRenderTechniques { using DefaultTechniqueBuilder = std::function&lt;void( RenderTechnique&amp;, bool )&gt;;</p>
<p>/** register a new default technique builder for a Material Type RA_ENGINE_API bool registerDefaultTechnique( const std::string&amp; name, DefaultTechniqueBuilder builder );</p>
<p>/** Remove a default technique builder RA_ENGINE_API bool removeDefaultTechnique( const std::string&amp; name );</p>
<p>/** Get the default technique builder for a Material Type RA_ENGINE_API std::pair&lt;bool, DefaultTechniqueBuilder&gt; getDefaultTechnique( const std::string&amp; name );</p>
<p>} // namespace EngineRenderTechniques ```</p>
<p><b>Note</b> that, if needed, an application could bypass the builder factory and construct directly a render technique. More, as the material is associated to the RenderObject component and not to the Render technique, an application with its own specific renderer could not use at all this functionality.</p>
<h2>Engine material management workflow</h2>
<p>For now (master v1), the engine manage only one default material corresponding the the Blinn-Phong BSDF. The type of this material is <code>"BlinnPhong"</code>. The workflow allowing the Engine to manage this material is the following.</p>
<h3>Making BlinnPhong a lodable material (see <em>The MaterialData interface</em>)</h3>
<p>This part of the Material management workflow is related to File loader. So, The corresponding classes are located in the <code>Core/File</code> subdirectory. ``` src └───Core │ └───File │ │ ... │ │ <a class="el" href="BlinnPhongMaterialData_8cpp.html">BlinnPhongMaterialData.cpp</a> │ │ <a class="el" href="BlinnPhongMaterialData_8hpp.html">BlinnPhongMaterialData.hpp</a> │ │ <a class="el" href="BlinnPhongMaterialData_8inl.html">BlinnPhongMaterialData.inl</a> │ │ ... │ ... ``<code> The</code>BlinnPhongMaterialData<code>class is defined as : </code>``cpp namespace <a class="el" href="namespaceRa.html" title="Functions in this file are utilities to compute the distance between various geometric sets...">Ra</a> { namespace Asset {</p>
<p>class RA_CORE_API BlinnPhongMaterialData : public MaterialData { public: explicit BlinnPhongMaterialData( const std::string&amp; name = "" ); ... };</p>
<p>} // namespace Asset } // namespace <a class="el" href="namespaceRa.html" title="Functions in this file are utilities to compute the distance between various geometric sets...">Ra</a> ```</p>
<p>Then, the Assimp loader, located in the <code>IO/AssimpLoader</code> subdirectory will instanciate the <code>BlinnPhongMaterialData</code> when loading a file in the following way : ```cpp void AssimpGeometryDataLoader::loadMaterial( const aiMaterial&amp; material, Asset::GeometryData&amp; data ) const { // Get the name of the material std::string matName; aiString assimpName; if ( AI_SUCCESS == material.Get( AI_MATKEY_NAME, assimpName ) ) { matName = assimpName.C_Str(); } // Instanciate a BlinnPhongMaterialData object auto blinnPhongMaterial = new Asset::BlinnPhongMaterialData( matName ); // Fill the BlinnPhongMaterialData structure ... // Associate the Material with the geometry data.setMaterial( blinnPhongMaterial ); } ```</p>
<h3>Making BlinnPhong a renderable material (see <em>The Material interface</em>)</h3>
<p>This part of the Material management workflow is related to the Renderer part of the Engine. So, The corresponding classes are located in the <code>Engine/Renderer/Material</code> subdirectory. ``` src └───Engine │ └───Renderer │ │ └───Material │ │ │ ... │ │ │ <a class="el" href="BlinnPhongMaterial_8cpp.html">BlinnPhongMaterial.cpp</a> │ │ │ <a class="el" href="BlinnPhongMaterial_8hpp.html">BlinnPhongMaterial.hpp</a> │ │ │ <a class="el" href="BlinnPhongMaterial_8inl.html">BlinnPhongMaterial.inl</a> │ │ │ ... │ │ ... │ ... ... ``<code> The</code>BlinnPhongMaterial<code>class is defined as : </code>``cpp namespace <a class="el" href="namespaceRa.html" title="Functions in this file are utilities to compute the distance between various geometric sets...">Ra</a> { namespace Engine {</p>
<p>class RA_ENGINE_API BlinnPhongMaterial final : public Material { public: RA_CORE_ALIGNED_NEW explicit BlinnPhongMaterial( const std::string&amp; name ); ... private: ... public: static void registerMaterial(); static void unregisterMaterial(); ...</p>
<p>};</p>
<p>} // namespace Engine } // namespace <a class="el" href="namespaceRa.html" title="Functions in this file are utilities to compute the distance between various geometric sets...">Ra</a> ```</p>
<h3>Registering the BlinnPhongMaterial to the Engine</h3>
<p>The registration (and unregistering) of a Material into the Engine consists in registering the material converter into the MaterialConvertersFactory and the RenderTechniqueBuilder into the RenderTechniqueFactory.</p>
<p>It is recommended (see above) to implement specific class methods in the Material implementations that will register and unregister the material type into the engine.</p>
<p>For the default <code>BlinnPhongMaterial</code>, wich is of type <code>"BlinnPhong"</code>, these methods will do the following :</p>
<p>```cpp void BlinnPhongMaterial::registerMaterial() { // 1- register the Material converter for loading EngineMaterialConverters::registerMaterialConverter( "BlinnPhong", BlinnPhongMaterialConverter() );</p>
<p>// 2- register the technique builder for rendering <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#affc37bf84d5ff81342b5c09587eedc34" title="register a new default builder for a technique ">Ra::Engine::EngineRenderTechniques::registerDefaultTechnique</a>( "BlinnPhong", []( <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>&amp; rt, bool isTransparent ) { // Configuration for RenderTechnique::LIGHTING_OPAQUE (Mandatory) <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> lpconfig( "BlinnPhong", "Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl", "Shaders/Materials/BlinnPhong/BlinnPhong.frag.glsl" ); Ra::Engine::ShaderConfigurationFactory::addConfiguration( lpconfig ); rt.setConfiguration( lpconfig, Ra::Engine::RenderTechnique::LIGHTING_OPAQUE );</p>
<p>// Configuration for RenderTechnique::Z_PREPASS <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> dpconfig( "DepthAmbiantBlinnPhong", "Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl", "Shaders/Materials/BlinnPhong/DepthAmbientBlinnPhong.frag.glsl" ); Ra::Engine::ShaderConfigurationFactory::addConfiguration( dpconfig ); rt.setConfiguration( dpconfig, Ra::Engine::RenderTechnique::Z_PREPASS );</p>
<p>// Configuration for RenderTechnique::LIGHTING_TRANSPARENT if ( isTransparent ) { <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> tpconfig( "LitOITBlinnPhong", "Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl", "Shaders/Materials/BlinnPhong/LitOITBlinnPhong.frag.glsl" ); Ra::Engine::ShaderConfigurationFactory::addConfiguration( tpconfig ); rt.setConfiguration( tpconfig, Ra::Engine::RenderTechnique::LIGHTING_TRANSPARENT ); } } ); }</p>
<p>void BlinnPhongMaterial::unregisterMaterial() { EngineMaterialConverters::removeMaterialConverter( "BlinnPhong" ); EngineRenderTechniques::removeDefaultTechnique( "BlinnPhong" ); } ```</p>
<p>As the <code>BlinnPhongMaterial</code> is directly managed by the Engine, registration of the material is realized at the initialization of the Engine. We then have, in the <code>RadiumEngine</code> class, the following method : ```cpp void RadiumEngine::initialize() { <a class="el" href="Log_8hpp.html#aba7b09d6e8fbe414c23705ad24dde6ff">LOG( logINFO )</a> &lt;&lt; "*** Radium Engine ***"; ... // Engine support some built-in materials. Register them here BlinnPhongMaterial::registerMaterial(); } ```</p>
<h3>Asssociate the material with a RenderTechnique inside a RenderObject</h3>
<p>The conversion of a <code>FileData</code> structure, resulting from the loading of a data file to entities and components that are managed by the Engine and Renderers are in charge of the loading system, by default the <code>FancyMesh</code> system.</p>
<p>Thanks to the <code>MaterialData</code> interface, the <code>Material</code> interface, the <code>EngineMaterialConverters</code> factory and the <code>EngineRenderTechniques</code> factory, this task is generic and is the same for every registered materials. So, once a material is developed following the above description, is will be directly usable in the <code>ForwardRenderer</code> thanks to the following <code>FancyMesh</code>method :</p>
<p>```cpp void FancyMeshComponent::handleMeshLoading( const Ra::Asset::GeometryData* data ) { // convert the GeometryData into a Renderable Mesh ... // Convert the MaterialData into a Material and its associated render technique</p>
<p>// First, get the concrete MaterialData const <a class="el" href="classRa_1_1Asset_1_1MaterialData.html" title="represent material data loaded by a file loader. ">Ra::Asset::MaterialData</a>&amp; loadedMaterial = data-&gt;getMaterial(); // Second, convert the material from asset to Engine auto converter = <a class="el" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ad440019d5fdaa657b3a483a705dc3657">Ra::Engine::EngineMaterialConverters::getMaterialConverter</a>( loadedMaterial.getType() ); std::shared_ptr&lt;Ra::Engine::Material&gt; radiumMaterial( converter.second( &amp;loadedMaterial ) ); // Third, associate the material to a render technique <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> rt; rt.setMaterial( radiumMaterial ); // Fourth, parameterize the technique for rendering this material auto builder = <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a5e831d5088144082e9bd3828323aa57a">Ra::Engine::EngineRenderTechniques::getDefaultTechnique</a>( loadedMaterial.getType() ); builder.second( rt, isTransparent );</p>
<p>// Create, parameterize and register the resulting RenderObject auto ro = <a class="el" href="classRa_1_1Engine_1_1RenderObject.html#ae9cb914f351555a60d29e8d6afedc06b" title="Sort of factory method to easily create a render object. ">Ra::Engine::RenderObject::createRenderObject</a>( roName, this, Ra::Engine::RenderObjectType::Fancy, displayMesh, rt ); ro-&gt;setTransparent( radiumMaterial-&gt;isTransparent() ); setupIO( m_contentName ); m_meshIndex = addRenderObject( ro ); } ```</p>
<h2>Extending the material library from a plugin</h2>
<p>Note that, as we will see in the <em>Extending the material library from a plugin</em> if one want to add a new loadable material in the Engine, this will require to define a loader capable of generating such data.</p>
<p>Given the description above, one can extend the material library from a plugin or from an application. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Nov 19 2018 21:15:52 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
